#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Trabajo práctico especial - Primera parte
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Integrantes
\end_layout

\begin_layout Description
Nombre
\begin_inset space ~
\end_inset

y
\begin_inset space ~
\end_inset

apellido: Abel Matías Osorio.
\end_layout

\begin_layout Description
Correo
\begin_inset space ~
\end_inset

electrónico: abel.m.osorio@gmail.com.
\end_layout

\begin_layout Description
Número
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

grupo: 
\emph on
60
\emph default
.
\end_layout

\begin_layout Description
Ayudante: Rubi, Pablo.
\end_layout

\begin_layout Section*
Especificación formal en 
\noun on
Nereus
\noun default
 y estructuras de datos
\end_layout

\begin_layout Subsection*
TDA 
\begin_inset Quotes eld
\end_inset

Lista
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

CLASS Fila [Elemento]
\end_layout

\begin_layout Plain Layout

  IMPORTS Nat
\end_layout

\begin_layout Plain Layout

  BASIC CONSTRUCTORS inicLista, agregarPrincipioLista, agregarFinalLista,
 agregarLista
\end_layout

\begin_layout Plain Layout

  EFFECTIVE
\end_layout

\begin_layout Plain Layout

    TYPE Lista
\end_layout

\begin_layout Plain Layout

    OPERATIONS
\end_layout

\begin_layout Plain Layout

      inicLista: -> Lista;
\end_layout

\begin_layout Plain Layout

      longLista: Lista -> Nat;
\end_layout

\begin_layout Plain Layout

      agregarPrincipioLista: Lista * Elemento -> Lista;
\end_layout

\begin_layout Plain Layout

      agregarFinalLista: Lista * Elemento -> Lista;
\end_layout

\begin_layout Plain Layout

      agregarLista: Lista(l) * Nat(i) * Elemento (e) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: (i >= 1) and (i <= longLista(l));
\end_layout

\begin_layout Plain Layout

      estaVacia: Lista -> Boolean;
\end_layout

\begin_layout Plain Layout

      eliminarLista: Lista(l) * Nat(i) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: (i >= 1) and (i <= longLista(l)) and not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      recuperarLista: Lista(l) * Nat(i) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: (i >= 1) and (i <= longLista(l)) and not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      estaIncluido: Lista(l) * Elemento -> Boolean
\end_layout

\begin_layout Plain Layout

        pre: not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      leerPrimero: Lista(l) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      leerSiguiente: Lista(l) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not estaVacia(l);
\end_layout

\begin_layout Plain Layout

END-CLASS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Estructura de datos utilizada
\end_layout

\begin_layout Standard
Para implementar el TDA 
\emph on
Lista
\emph default
 se utilizó un 
\emph on
struct 
\emph default
\noun on
Nodo
\noun default
 con los siguientes atributos:
\end_layout

\begin_layout Description
elemento Almacena el valor del nodo.
\end_layout

\begin_layout Description
siguiente Puntero al siguiente nodo de la lista.
 
\end_layout

\begin_layout Standard
Esta estructura permite una fácil implemenación de la lista, y además permite
 poder agregar elementos de manera flexible sin ningún límite de tamaño.
 Además, se utiliza sólo la memoria necesaria para almacenar los elementos
 de la lista, es decir, no es necesario reservar memoria para futuros posibles
 elementos.
 Como punto en contra, no se tiene una forma directa de acceder a un elemento
 arbitrario de la lista, sino que hay que recorrer la misma hasta llegar
 al elemento buscado.
 Con una estructura como, por ejemplo, un arreglo, se podría mejorar el
 acceso a nodos arbitrarios de la lista y determinar fácilmente cuál es
 el primer y último nodo, entre otras cosas.
 Sin embargo, sería necesario reservar, al momento de inicializar la lista,
 un bloque de memoria contiguo lo suficientemente grande como para poder
 generar las listas que se quieran.
\end_layout

\begin_layout Subsection*
TDA 
\begin_inset Quotes eld
\end_inset

Arbol
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

CLASS Arbin [Elemento]
\end_layout

\begin_layout Plain Layout

  IMPORTS Nat, Lista
\end_layout

\begin_layout Plain Layout

  BASIC CONSTRUCTORS inicArbin, agregarElemento
\end_layout

\begin_layout Plain Layout

  EFFECTIVE
\end_layout

\begin_layout Plain Layout

    TYPE Arbin
\end_layout

\begin_layout Plain Layout

    OPERATIONS
\end_layout

\begin_layout Plain Layout

      inicArbin: -> Arbin;
\end_layout

\begin_layout Plain Layout

      vacioArbin: Arbin -> Boolean;
\end_layout

\begin_layout Plain Layout

      recuperarRaiz: Arbin(t) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      agregarElemento: Arbin * Elemento -> Arbin;
\end_layout

\begin_layout Plain Layout

      listarInorden: Arbin(t) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      estaIncluido: Arbin(t) * Elemento -> Boolean
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      cantidadNodos: Arbin -> Nat;
\end_layout

\begin_layout Plain Layout

      profundidad: Arbin -> Nat;
\end_layout

\begin_layout Plain Layout

      construirFrontera: Arbin(t) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

END-CLASS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Estructura de datos utilizada
\end_layout

\begin_layout Standard
Para implementar el TDA 
\emph on
Arbin
\emph default
 se utilizó una estructura recursiva de 
\emph on
structs
\emph default
 
\noun on
Nodo
\noun default
 con los siguientes atributos:
\end_layout

\begin_layout Description
elemento Almacena el valor del nodo.
\end_layout

\begin_layout Description
subIzquierdo Puntero al nodo izquierdo.
\end_layout

\begin_layout Description
subDerecho Puntero al nodo derecho.
\end_layout

\begin_layout Standard
Todos los valores que estén almacenados en la rama izquierda serán menores
 a la raíz, y todos los almacenados a la derecha mayores.
 La ventaja de utilizar esta estructura es que permite recorrer el árbol
 de manera recursiva obteniendo, en general, complejidades logarítmicas,
 y a su vez el espacio que ocupa en memoria es prácticamente sólo el que
 necesita para almacenar los valores contenidos, sin necesidad de sobredimension
ar ninguna estructura.
\end_layout

\begin_layout Section*
Código fuente
\end_layout

\begin_layout Subsection*
Implementación del TDA 
\emph on
Lista
\end_layout

\begin_layout Subsubsection*
lista.h
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},basicstyle={\normalsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#ifndef LISTA_H_INCLUDED 
\end_layout

\begin_layout Plain Layout

#define LISTA_H_INCLUDED
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

class Lista {
\end_layout

\begin_layout Plain Layout

    private:
\end_layout

\begin_layout Plain Layout

        struct Nodo {
\end_layout

\begin_layout Plain Layout

            Elem elemento;
\end_layout

\begin_layout Plain Layout

            Nodo * siguiente;
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

        // Inicio de la lista.
\end_layout

\begin_layout Plain Layout

        Nodo * inicio;
\end_layout

\begin_layout Plain Layout

        // Puntero para recorrer la lista.
 Indica la posición del elemento
\end_layout

\begin_layout Plain Layout

        // apuntado.
 Comienza en 1.
\end_layout

\begin_layout Plain Layout

        int punteroPosicion;
\end_layout

\begin_layout Plain Layout

        // Puntero para recorrer la lista.
 Es el puntero real del elemento
\end_layout

\begin_layout Plain Layout

        // apuntado.
\end_layout

\begin_layout Plain Layout

        Nodo * puntero = NULL;
\end_layout

\begin_layout Plain Layout

        // Función para vaciar la lista.
\end_layout

\begin_layout Plain Layout

        void vaciar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public:
\end_layout

\begin_layout Plain Layout

        // Inicializadora de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        Lista();
\end_layout

\begin_layout Plain Layout

        // Destructora de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        ~Lista();
\end_layout

\begin_layout Plain Layout

        // Devuelve el tamaño de la lista (cantidad de elementos incluídos).
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        int longLista() const;
\end_layout

\begin_layout Plain Layout

        // Agrega un elemento al principio de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void agregarPrincipioLista(Elem);
\end_layout

\begin_layout Plain Layout

        // Agrega un elemento al final de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void agregarFinalLista(Elem);
\end_layout

\begin_layout Plain Layout

        // Agrega un elemento en una posición de determinada de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void agregarLista(int, Elem);
\end_layout

\begin_layout Plain Layout

        // Elimina un elemento de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void eliminarLista(int);
\end_layout

\begin_layout Plain Layout

        // Devuelve el elemento de una posición determinada.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void recuperarLista(int, Elem &) const;
\end_layout

\begin_layout Plain Layout

        // Indica si un elemento está incluído en la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        bool estaIncluido(Elem) const;
\end_layout

\begin_layout Plain Layout

        // Función para chequear si la lista está vacía.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        bool estaVacia() const;
\end_layout

\begin_layout Plain Layout

        // Función para mostrar el valor actual de la lista.
 El valor es
\end_layout

\begin_layout Plain Layout

        // almacenado en el parámetro que pasa por referencia.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void leerPrimero(Elem &);
\end_layout

\begin_layout Plain Layout

        // Función para obtener el próximo valor de la lista.
 El puntero
\end_layout

\begin_layout Plain Layout

        // se corre a la próxima posición.
 El valor es almacenado en el
\end_layout

\begin_layout Plain Layout

        // parámetro que pasa por referencia.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void leerSiguiente(Elem &); };
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
lista.cpp
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},basicstyle={\normalsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include "lista.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Constructora del objeto.
\end_layout

\begin_layout Plain Layout

 * Inicializa el primer nodo con valores NULL.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

Lista<Elem>::Lista() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    inicio = NULL;
\end_layout

\begin_layout Plain Layout

    punteroPosicion = 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Destructora del objeto.
\end_layout

\begin_layout Plain Layout

 * Llama a vaciar() para eliminar todos los nodos de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

Lista<Elem>::~Lista()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    vaciar();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para vaciar la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::vaciar()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * aux;
\end_layout

\begin_layout Plain Layout

    while (inicio->siguiente != NULL) {
\end_layout

\begin_layout Plain Layout

        aux = inicio->siguiente->siguiente;
\end_layout

\begin_layout Plain Layout

        delete inicio->siguiente;
\end_layout

\begin_layout Plain Layout

        inicio->siguiente = aux;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    inicio->siguiente = NULL;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para agregar un elemento al principio de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::agregarPrincipioLista(Elem valor)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

    nuevo->siguiente = inicio;
\end_layout

\begin_layout Plain Layout

    nuevo->elemento = valor;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    inicio = nuevo;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para agregar un elemento al final de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::agregarFinalLista(Elem valor)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        while (aux->siguiente != NULL) {
\end_layout

\begin_layout Plain Layout

            aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

        nuevo->siguiente = NULL;
\end_layout

\begin_layout Plain Layout

        nuevo->elemento = valor;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        aux->siguiente = nuevo;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        // La lista está vacía.
 Agregar el elemento al inicio o al final de
\end_layout

\begin_layout Plain Layout

        // la lista, es lo mismo.
\end_layout

\begin_layout Plain Layout

        agregarPrincipioLista(valor);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para agregar un elemento en una posición arbitraria de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::agregarLista(int posicion, Elem valor)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if ((posicion < 1) or (posicion > longLista()) or estaVacia()) {
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

    int actual = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        while (aux->siguiente != NULL and posicion < actual) {
\end_layout

\begin_layout Plain Layout

            aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

        nuevo->siguiente = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        nuevo->elemento = valor;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        aux = nuevo;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        // La lista está vacía.
 Se agrega el elemento al principio.
\end_layout

\begin_layout Plain Layout

        agregarPrincipioLista(valor);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Devuelve el tamaño de la lista (cantidad de elementos incluídos).
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

int Lista<Elem>::longLista() const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    int longitud = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        longitud++;
\end_layout

\begin_layout Plain Layout

        aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return longitud;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para determinar si un elemento está incluído en la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Lista<Elem>::estaIncluido(Elem buscado) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (estaVacia()) {
\end_layout

\begin_layout Plain Layout

        return false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    while (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        if (aux->elemento == buscado) {
\end_layout

\begin_layout Plain Layout

            return true;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para chequear si la lista está vacía.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Lista<Elem>::estaVacia() const {
\end_layout

\begin_layout Plain Layout

    return (inicio == NULL);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para eliminar un elemento de una posición determinada.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::eliminarLista(int posicion)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    // Si la posición es menor a 1 o excede la longitud de la lista, entonces
\end_layout

\begin_layout Plain Layout

    // no hago nada.
\end_layout

\begin_layout Plain Layout

    if ((posicion < 1) or (posicion > longLista()) or estaVacia()) {
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    int actual = 1;
\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    Nodo * victima;
\end_layout

\begin_layout Plain Layout

    Nodo * anterior = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (actual < posicion) {
\end_layout

\begin_layout Plain Layout

        anterior = aux;
\end_layout

\begin_layout Plain Layout

        aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        actual++;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    victima = aux;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (anterior != NULL) {
\end_layout

\begin_layout Plain Layout

        anterior->siguiente = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        // Se está borrando el primer nodo, por lo tanto hay que
\end_layout

\begin_layout Plain Layout

        // actualizar el puntero de inicio de la lista.
\end_layout

\begin_layout Plain Layout

        inicio = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    delete victima;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para obtener un valor de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::recuperarLista(int posicion, Elem & valor) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if ((posicion < 1) or (posicion > longLista()) or estaVacia()) {
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    int actual = 1;
\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (actual < posicion) {
\end_layout

\begin_layout Plain Layout

        actual++;
\end_layout

\begin_layout Plain Layout

        aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    valor = aux->elemento;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para obtener el primer valor de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::leerPrimero(Elem & primero)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (!estaVacia()) {
\end_layout

\begin_layout Plain Layout

        primero = inicio->elemento;
\end_layout

\begin_layout Plain Layout

        punteroPosicion = 2;
\end_layout

\begin_layout Plain Layout

        puntero = inicio->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para obtener el próximo valor de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::leerSiguiente(Elem & siguiente)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (!estaVacia()) {
\end_layout

\begin_layout Plain Layout

        if (punteroPosicion <= longLista()) {
\end_layout

\begin_layout Plain Layout

            siguiente = puntero->elemento;
\end_layout

\begin_layout Plain Layout

            puntero = puntero->siguiente;
\end_layout

\begin_layout Plain Layout

            punteroPosicion++;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tipos para los cuales la clase está implementada
\end_layout

\begin_layout Plain Layout

template class Lista<unsigned int>;
\end_layout

\begin_layout Plain Layout

template class Lista<int>;
\end_layout

\begin_layout Plain Layout

template class Lista<float>;
\end_layout

\begin_layout Plain Layout

template class Lista<char>;
\end_layout

\begin_layout Plain Layout

template class Lista<string>;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Implementación del TDA 
\emph on
Arbin
\end_layout

\begin_layout Subsubsection*
arbin.h
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},basicstyle={\normalsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#ifndef ARBOL_BINARIO_H_INCLUDED
\end_layout

\begin_layout Plain Layout

#define ARBOL_BINARIO_H_INCLUDED
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

#include "lista.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

class Arbin {
\end_layout

\begin_layout Plain Layout

    private:
\end_layout

\begin_layout Plain Layout

        struct Nodo {
\end_layout

\begin_layout Plain Layout

            Elem elemento;
\end_layout

\begin_layout Plain Layout

            Nodo * subIzquierdo;
\end_layout

\begin_layout Plain Layout

            Nodo * subDerecho;
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        // Nodo raíz del árbol binario.
\end_layout

\begin_layout Plain Layout

        Nodo * raiz = NULL;
\end_layout

\begin_layout Plain Layout

        // Función privada para eliminar todos los nodos del árbol.
\end_layout

\begin_layout Plain Layout

        void vaciar(Nodo *);
\end_layout

\begin_layout Plain Layout

        // Función privada para agregar un elemento al árbol.
\end_layout

\begin_layout Plain Layout

        void agregarElemento(Nodo *, Elem);
\end_layout

\begin_layout Plain Layout

        // Función privada para lista los elementos del árbol inorden.
\end_layout

\begin_layout Plain Layout

        void listarInorden(Nodo *, Lista<Elem> * &) const;
\end_layout

\begin_layout Plain Layout

        // Función privada para determinar si un elemento está incluído
 en el
\end_layout

\begin_layout Plain Layout

        // árbol.
\end_layout

\begin_layout Plain Layout

        void estaIncluido(Nodo *, Elem, bool &) const;
\end_layout

\begin_layout Plain Layout

        // Función privada para contar la cantidad de elementos del árbol.
\end_layout

\begin_layout Plain Layout

        int cantidadNodos(Nodo *) const;
\end_layout

\begin_layout Plain Layout

        // Función privada para determinar la profundidad del árbol.
\end_layout

\begin_layout Plain Layout

        int profundidad(Nodo *) const;
\end_layout

\begin_layout Plain Layout

        // Función para determinar si un nodo es hoja.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        bool esHoja(Nodo *) const;
\end_layout

\begin_layout Plain Layout

        // Función privada para construir la frontera del árbol.
\end_layout

\begin_layout Plain Layout

        void construirFrontera(Nodo *, Lista<Elem> * &) const;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public:
\end_layout

\begin_layout Plain Layout

        // Función constructora del árbol binario.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        Arbin();
\end_layout

\begin_layout Plain Layout

        // Función destructora del árbol.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        ~Arbin();
\end_layout

\begin_layout Plain Layout

        // Función para determinar si el árbol está vacío.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        bool vacioArbin() const;
\end_layout

\begin_layout Plain Layout

        // Función para obtener el elemento raíz del árbol.
\end_layout

\begin_layout Plain Layout

        // El valor de la raíz se almacenará en el parámetro enviado.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void recuperarRaiz(Elem &) const;
\end_layout

\begin_layout Plain Layout

        // Función para agregar un elemento al árbol.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(log(n)).
\end_layout

\begin_layout Plain Layout

        void agregarElemento(Elem);
\end_layout

\begin_layout Plain Layout

        // Función para listar los elementos del árbol inorden.
\end_layout

\begin_layout Plain Layout

        // Los elementos se agregarán en la lista pasada como parámetro.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void listarInorden(Lista<Elem> * &) const;
\end_layout

\begin_layout Plain Layout

        // Función para determinar si un elemento está incluído en el árbol.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(log(n)).
\end_layout

\begin_layout Plain Layout

        bool estaIncluido(Elem) const;
\end_layout

\begin_layout Plain Layout

        // Función para contar la cantidad de nodos que tiene el árbol.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        int cantidadNodos() const;
\end_layout

\begin_layout Plain Layout

        // Función para determinar la profundidad del árbol.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        int profundidad() const;
\end_layout

\begin_layout Plain Layout

        // Función para construir la frontera del árbol.
\end_layout

\begin_layout Plain Layout

        // Los elementos de la frontera se agregarán en la lista pasada
 como
\end_layout

\begin_layout Plain Layout

        // parámetro.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void construirFrontera(Lista<Elem> * &) const;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
arbin.cpp
\end_layout

\begin_layout Subsubsection*
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},basicstyle={\normalsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include "arbin.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Inicializadora del árbol binario.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

Arbin<Elem>::Arbin()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    raiz = NULL;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Destructora del árbol binario.
\end_layout

\begin_layout Plain Layout

 * Ejecuta vaciar() para eliminar uno a uno los nodos del árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

Arbin<Elem>::~Arbin()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    vaciar(raiz);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para eliminar, uno a uno, todos los nodos del árbol binario.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::vaciar(Nodo * arbol)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (arbol != NULL) {
\end_layout

\begin_layout Plain Layout

        vaciar(arbol->subIzquierdo);
\end_layout

\begin_layout Plain Layout

        vaciar(arbol->subDerecho);
\end_layout

\begin_layout Plain Layout

        delete arbol;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para determinar si el árbol binario está vacío.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Arbin<Elem>::vacioArbin() const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return (raiz == NULL);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para obtener el elemento raíz del árbol (si no está vacío).
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::recuperarRaiz(Elem & valor) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (!vacioArbin()) {
\end_layout

\begin_layout Plain Layout

        valor = raiz->elemento;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para agregar un elemento al árbol binario.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::agregarElemento(Nodo * arbol, Elem elemento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (elemento <= arbol->elemento) {
\end_layout

\begin_layout Plain Layout

        // Insertar en rama izquierda
\end_layout

\begin_layout Plain Layout

        if (arbol->subIzquierdo != NULL) {
\end_layout

\begin_layout Plain Layout

            agregarElemento(arbol->subIzquierdo, elemento);
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

            Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

            nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

            nuevo->elemento = elemento;
\end_layout

\begin_layout Plain Layout

            nuevo->subIzquierdo = NULL;
\end_layout

\begin_layout Plain Layout

            nuevo->subDerecho = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            arbol->subIzquierdo = nuevo;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        // Insertar en rama derecha
\end_layout

\begin_layout Plain Layout

        if (arbol->subDerecho != NULL) {
\end_layout

\begin_layout Plain Layout

            agregarElemento(arbol->subDerecho, elemento);
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

            Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

            nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

            nuevo->elemento = elemento;
\end_layout

\begin_layout Plain Layout

            nuevo->subIzquierdo = NULL;
\end_layout

\begin_layout Plain Layout

            nuevo->subDerecho = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

            arbol->subDerecho = nuevo;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función pública para agregar un elemento al árbol binario.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::agregarElemento(Elem elemento)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (raiz == NULL) {
\end_layout

\begin_layout Plain Layout

        // El arbol está vacío
\end_layout

\begin_layout Plain Layout

        Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

        nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

        nuevo->elemento = elemento;
\end_layout

\begin_layout Plain Layout

        nuevo->subIzquierdo = NULL;
\end_layout

\begin_layout Plain Layout

        nuevo->subDerecho = NULL;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        raiz = nuevo;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        agregarElemento(raiz, elemento);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para listar los elementos del árbol inorden.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::listarInorden(Nodo * arbol, Lista<Elem> * & lista) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (arbol != NULL) {
\end_layout

\begin_layout Plain Layout

        listarInorden(arbol->subIzquierdo, lista);
\end_layout

\begin_layout Plain Layout

        lista->agregarFinalLista(arbol->elemento);
\end_layout

\begin_layout Plain Layout

        listarInorden(arbol->subDerecho, lista);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función pública para listar los elementos del árbol inorden.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::listarInorden(Lista<Elem> * & lista) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (!vacioArbin()) {
\end_layout

\begin_layout Plain Layout

        listarInorden(raiz, lista);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para determinar si un elemento está en el árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::estaIncluido(Nodo * arbol, Elem valor, bool & existe)
 const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (arbol != NULL) {
\end_layout

\begin_layout Plain Layout

        if (arbol->elemento == valor) {
\end_layout

\begin_layout Plain Layout

            existe = true;
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

            if (valor < arbol->elemento) {
\end_layout

\begin_layout Plain Layout

                estaIncluido(arbol->subIzquierdo, valor, existe);
\end_layout

\begin_layout Plain Layout

            } else {
\end_layout

\begin_layout Plain Layout

                estaIncluido(arbol->subDerecho, valor, existe);
\end_layout

\begin_layout Plain Layout

            }
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función pública para determinar si un elemento está en el árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Arbin<Elem>::estaIncluido(Elem valor) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (vacioArbin()) {
\end_layout

\begin_layout Plain Layout

        return false;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        bool existe = false;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        estaIncluido(raiz, valor, existe);
\end_layout

\begin_layout Plain Layout

        return existe;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para contar la cantidad de elementos que tiene el árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

int Arbin<Elem>::cantidadNodos(Nodo * arbol) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (arbol == NULL) {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        return (1 + cantidadNodos(arbol->subIzquierdo) + cantidadNodos(arbol->su
bDerecho));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función pública para contar la cantidad de elementos que tiene el árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

int Arbin<Elem>::cantidadNodos() const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return cantidadNodos(raiz);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para determinar la profundidad del árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

int Arbin<Elem>::profundidad(Nodo * arbol) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (arbol == NULL) {
\end_layout

\begin_layout Plain Layout

        return 0;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        return (1 + max(profundidad(arbol->subIzquierdo), profundidad(arbol->sub
Derecho)));
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función pública para determinar la profundidad del árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

int Arbin<Elem>::profundidad() const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return profundidad(raiz);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para determinar si un nodo es hoja.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Arbin<Elem>::esHoja(Nodo * nodo) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    return (nodo != NULL and nodo->subIzquierdo == NULL and nodo->subDerecho
 == NULL);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para construir la frontera del árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::construirFrontera(Nodo * nodo, Lista<Elem> * & frontera)
 const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (nodo != NULL) {
\end_layout

\begin_layout Plain Layout

        if (esHoja(nodo)) {
\end_layout

\begin_layout Plain Layout

            frontera->agregarFinalLista(nodo->elemento);
\end_layout

\begin_layout Plain Layout

        } else {
\end_layout

\begin_layout Plain Layout

            construirFrontera(nodo->subIzquierdo, frontera);
\end_layout

\begin_layout Plain Layout

            construirFrontera(nodo->subDerecho, frontera);
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función privada para construir la frontera del árbol.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Arbin<Elem>::construirFrontera(Lista<Elem> * & frontera) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (!vacioArbin()) {
\end_layout

\begin_layout Plain Layout

        construirFrontera(raiz, frontera);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tipos para los cuales la clase está implementada
\end_layout

\begin_layout Plain Layout

template class Arbin<unsigned int>;
\end_layout

\begin_layout Plain Layout

template class Arbin<int>;
\end_layout

\begin_layout Plain Layout

template class Arbin<float>;
\end_layout

\begin_layout Plain Layout

template class Arbin<char>;
\end_layout

\begin_layout Plain Layout

template class Arbin<string>;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
