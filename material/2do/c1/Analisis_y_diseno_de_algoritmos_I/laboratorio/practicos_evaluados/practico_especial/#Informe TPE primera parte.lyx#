#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Trabajo práctico especial - Primera parte
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Integrantes
\end_layout

\begin_layout Description
Nombre
\begin_inset space ~
\end_inset

y
\begin_inset space ~
\end_inset

apellido: Abel Matías Osorio.
\end_layout

\begin_layout Description
Correo
\begin_inset space ~
\end_inset

electrónico: abel.m.osorio@gmail.com.
\end_layout

\begin_layout Description
Número
\begin_inset space ~
\end_inset

de
\begin_inset space ~
\end_inset

grupo: 
\emph on
60
\emph default
.
\end_layout

\begin_layout Description
Ayudante: Rubi, Pablo.
\end_layout

\begin_layout Section*
Especificación formal en 
\noun on
Nereus
\noun default
 y estructuras de datos
\end_layout

\begin_layout Subsection*
TDA 
\begin_inset Quotes eld
\end_inset

Lista
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

CLASS Fila [Elemento]
\end_layout

\begin_layout Plain Layout

  IMPORTS Nat
\end_layout

\begin_layout Plain Layout

  BASIC CONSTRUCTORS inicLista, agregarPrincipioLista, agregarFinalLista,
 agregarLista
\end_layout

\begin_layout Plain Layout

  EFFECTIVE
\end_layout

\begin_layout Plain Layout

    TYPE Lista
\end_layout

\begin_layout Plain Layout

    OPERATIONS
\end_layout

\begin_layout Plain Layout

      inicLista: -> Lista;
\end_layout

\begin_layout Plain Layout

      longLista: Lista -> Nat;
\end_layout

\begin_layout Plain Layout

      agregarPrincipioLista: Lista * Elemento -> Lista;
\end_layout

\begin_layout Plain Layout

      agregarFinalLista: Lista * Elemento -> Lista;
\end_layout

\begin_layout Plain Layout

      agregarLista: Lista(l) * Nat(i) * Elemento (e) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: (i >= 1) and (i <= longLista(l));
\end_layout

\begin_layout Plain Layout

      estaVacia: Lista -> Boolean;
\end_layout

\begin_layout Plain Layout

      eliminarLista: Lista(l) * Nat(i) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: (i >= 1) and (i <= longLista(l)) and not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      recuperarLista: Lista(l) * Nat(i) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: (i >= 1) and (i <= longLista(l)) and not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      estaIncluido: Lista(l) * Elemento -> Boolean
\end_layout

\begin_layout Plain Layout

        pre: not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      leerPrimero: Lista(l) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not estaVacia(l);
\end_layout

\begin_layout Plain Layout

      leerSiguiente: Lista(l) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not estaVacia(l);
\end_layout

\begin_layout Plain Layout

END-CLASS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Estructura de datos utilizada
\end_layout

\begin_layout Standard
Para implementar el TDA 
\emph on
Lista
\emph default
 se utilizó un 
\emph on
struct 
\emph default
\noun on
Nodo
\noun default
 con los siguientes atributos:
\end_layout

\begin_layout Description
elemento Almacena el valor del nodo.
\end_layout

\begin_layout Description
siguiente Puntero al siguiente nodo de la lista.
 
\end_layout

\begin_layout Standard
Esta estructura permite una fácil implemenación de la lista, y además permite
 poder agregar elementos de manera flexible sin ningún límite de tamaño.
 Además, se utiliza sólo la memoria necesaria para almacenar los elementos
 de la lista, es decir, no es necesario reservar memoria para futuros posibles
 elementos.
 Como punto en contra, no se tiene una forma directa de acceder a un elemento
 arbitrario de la lista, sino que hay que recorrer la misma hasta llegar
 al elemento buscado.
 Con una estructura como, por ejemplo, un arreglo, se podría mejorar el
 acceso a nodos arbitrarios de la lista y determinar fácilmente cuál es
 el primer y último nodo, entre otras cosas.
 Sin embargo, sería necesario reservar, al momento de inicializar la lista,
 un bloque de memoria contiguo lo suficientemente grande como para poder
 generar las listas que se quieran.
\end_layout

\begin_layout Subsection*
TDA 
\begin_inset Quotes eld
\end_inset

Arbol
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

CLASS Arbin [Elemento]
\end_layout

\begin_layout Plain Layout

  IMPORTS Nat, Lista
\end_layout

\begin_layout Plain Layout

  BASIC CONSTRUCTORS inicArbin, agregarElemento
\end_layout

\begin_layout Plain Layout

  EFFECTIVE
\end_layout

\begin_layout Plain Layout

    TYPE Arbin
\end_layout

\begin_layout Plain Layout

    OPERATIONS
\end_layout

\begin_layout Plain Layout

      inicArbin: -> Arbin;
\end_layout

\begin_layout Plain Layout

      vacioArbin: Arbin -> Boolean;
\end_layout

\begin_layout Plain Layout

      recuperarRaiz: Arbin(t) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      agregarElemento: Arbin * Elemento -> Arbin;
\end_layout

\begin_layout Plain Layout

      listarInorden: Arbin(t) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      estaIncluido: Arbin(t) * Elemento -> Boolean
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      cantidadNodos: Arbin -> Nat;
\end_layout

\begin_layout Plain Layout

      profundidad: Arbin -> Nat;
\end_layout

\begin_layout Plain Layout

      construirFrontera: Arbin(t) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

END-CLASS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
Estructura de datos utilizada
\end_layout

\begin_layout Standard
Para implementar el TDA 
\emph on
Arbin
\emph default
 se utilizó una estructura recursiva de 
\emph on
structs
\emph default
 
\noun on
Nodo
\noun default
 con los siguientes atributos:
\end_layout

\begin_layout Description
elemento Almacena el valor del nodo.
\end_layout

\begin_layout Description
subIzquierdo Puntero al nodo izquierdo.
\end_layout

\begin_layout Description
subDerecho Puntero al nodo derecho.
\end_layout

\begin_layout Standard
Todos los valores que estén almacenados en la rama izquierda serán menores
 a la raíz, y todos los almacenados a la derecha mayores.
 La ventaja de utilizar esta estructura es que permite recorrer el árbol
 de manera recursiva obteniendo, en general, complejidades logarítmicas,
 y a su vez el espacio que ocupa en memoria es prácticamente sólo el que
 necesita para almacenar los valores contenidos.
\end_layout

\begin_layout Section*
Código fuente
\end_layout

\begin_layout Subsection*
Implementación del TDA 
\emph on
Lista
\end_layout

\begin_layout Subsubsection*
lista.h
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},basicstyle={\normalsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#ifndef LISTA_H_INCLUDED 
\end_layout

\begin_layout Plain Layout

#define LISTA_H_INCLUDED
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include <iostream>
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

using namespace std;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

class Lista {
\end_layout

\begin_layout Plain Layout

    private:
\end_layout

\begin_layout Plain Layout

        struct Nodo {
\end_layout

\begin_layout Plain Layout

            Elem elemento;
\end_layout

\begin_layout Plain Layout

            Nodo * siguiente;
\end_layout

\begin_layout Plain Layout

        };
\end_layout

\begin_layout Plain Layout

        // Inicio de la lista.
\end_layout

\begin_layout Plain Layout

        Nodo * inicio;
\end_layout

\begin_layout Plain Layout

        // Puntero para recorrer la lista.
 Indica la posición del elemento
\end_layout

\begin_layout Plain Layout

        // apuntado.
 Comienza en 1.
\end_layout

\begin_layout Plain Layout

        int punteroPosicion;
\end_layout

\begin_layout Plain Layout

        // Puntero para recorrer la lista.
 Es el puntero real del elemento
\end_layout

\begin_layout Plain Layout

        // apuntado.
\end_layout

\begin_layout Plain Layout

        Nodo * puntero = NULL;
\end_layout

\begin_layout Plain Layout

        // Función para vaciar la lista.
\end_layout

\begin_layout Plain Layout

        void vaciar();
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    public:
\end_layout

\begin_layout Plain Layout

        // Inicializadora de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        Lista();
\end_layout

\begin_layout Plain Layout

        // Destructora de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        ~Lista();
\end_layout

\begin_layout Plain Layout

        // Devuelve el tamaño de la lista (cantidad de elementos incluídos).
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        int longLista() const;
\end_layout

\begin_layout Plain Layout

        // Agrega un elemento al principio de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void agregarPrincipioLista(Elem);
\end_layout

\begin_layout Plain Layout

        // Agrega un elemento al final de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void agregarFinalLista(Elem);
\end_layout

\begin_layout Plain Layout

        // Agrega un elemento en una posición de determinada de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void agregarLista(int, Elem);
\end_layout

\begin_layout Plain Layout

        // Elimina un elemento de la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void eliminarLista(int);
\end_layout

\begin_layout Plain Layout

        // Devuelve el elemento de una posición determinada.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        void recuperarLista(int, Elem &) const;
\end_layout

\begin_layout Plain Layout

        // Indica si un elemento está incluído en la lista.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(n).
\end_layout

\begin_layout Plain Layout

        bool estaIncluido(Elem) const;
\end_layout

\begin_layout Plain Layout

        // Función para chequear si la lista está vacía.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        bool estaVacia() const;
\end_layout

\begin_layout Plain Layout

        // Función para mostrar el valor actual de la lista.
 El valor es
\end_layout

\begin_layout Plain Layout

        // almacenado en el parámetro que pasa por referencia.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void leerPrimero(Elem &);
\end_layout

\begin_layout Plain Layout

        // Función para obtener el próximo valor de la lista.
 El puntero
\end_layout

\begin_layout Plain Layout

        // se corre a la próxima posición.
 El valor es almacenado en el
\end_layout

\begin_layout Plain Layout

        // parámetro que pasa por referencia.
\end_layout

\begin_layout Plain Layout

        // Complejidad: O(1).
\end_layout

\begin_layout Plain Layout

        void leerSiguiente(Elem &); };
\end_layout

\begin_layout Plain Layout

#endif
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection*
lista.cpp
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "language={C++},basicstyle={\normalsize\ttfamily},tabsize=4"
inline false
status open

\begin_layout Plain Layout

#include "lista.h"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Constructora del objeto.
\end_layout

\begin_layout Plain Layout

 * Inicializa el primer nodo con valores NULL.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

Lista<Elem>::Lista() 
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    inicio = NULL;
\end_layout

\begin_layout Plain Layout

    punteroPosicion = 1;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Destructora del objeto.
\end_layout

\begin_layout Plain Layout

 * Llama a vaciar() para eliminar todos los nodos de la lista.
\end_layout

\begin_layout Plain Layout

*/
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

Lista<Elem>::~Lista()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    vaciar();
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para vaciar la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::vaciar()
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * aux;
\end_layout

\begin_layout Plain Layout

    while (inicio->siguiente != NULL) {
\end_layout

\begin_layout Plain Layout

        aux = inicio->siguiente->siguiente;
\end_layout

\begin_layout Plain Layout

        delete inicio->siguiente;
\end_layout

\begin_layout Plain Layout

        inicio->siguiente = aux;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    inicio->siguiente = NULL;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para agregar un elemento al principio de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::agregarPrincipioLista(Elem valor)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

    nuevo->siguiente = inicio;
\end_layout

\begin_layout Plain Layout

    nuevo->elemento = valor;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    inicio = nuevo;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para agregar un elemento al final de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::agregarFinalLista(Elem valor)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        while (aux->siguiente != NULL) {
\end_layout

\begin_layout Plain Layout

            aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

        nuevo->siguiente = NULL;
\end_layout

\begin_layout Plain Layout

        nuevo->elemento = valor;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        aux->siguiente = nuevo;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        // La lista está vacía.
 Agregar el elemento al inicio o al final de
\end_layout

\begin_layout Plain Layout

        // la lista, es lo mismo.
\end_layout

\begin_layout Plain Layout

        agregarPrincipioLista(valor);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para agregar un elemento en una posición arbitraria de la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

void Lista<Elem>::agregarLista(int posicion, Elem valor)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if ((posicion < 1) or (posicion > longLista()) or estaVacia()) {
\end_layout

\begin_layout Plain Layout

        return;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    Nodo * nuevo;
\end_layout

\begin_layout Plain Layout

    int actual = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    if (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        while (aux->siguiente != NULL and posicion < actual) {
\end_layout

\begin_layout Plain Layout

            aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        nuevo = new Nodo;
\end_layout

\begin_layout Plain Layout

        nuevo->siguiente = aux->siguiente;
\end_layout

\begin_layout Plain Layout

        nuevo->elemento = valor;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

        aux = nuevo;
\end_layout

\begin_layout Plain Layout

    } else {
\end_layout

\begin_layout Plain Layout

        // La lista está vacía.
 Se agrega el elemento al principio.
\end_layout

\begin_layout Plain Layout

        agregarPrincipioLista(valor);
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Devuelve el tamaño de la lista (cantidad de elementos incluídos).
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

int Lista<Elem>::longLista() const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    int longitud = 0;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    while (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        longitud++;
\end_layout

\begin_layout Plain Layout

        aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return longitud;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para determinar si un elemento está incluído en la lista.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Lista<Elem>::estaIncluido(Elem buscado) const
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

    if (estaVacia()) {
\end_layout

\begin_layout Plain Layout

        return false;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    while (aux != NULL) {
\end_layout

\begin_layout Plain Layout

        if (aux->elemento == buscado) {
\end_layout

\begin_layout Plain Layout

            return true;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

        aux = aux->siguiente;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    return false;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

/* Función para chequear si la lista está vacía.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

template <typename Elem>
\end_layout

\begin_layout Plain Layout

bool Lista<Elem>::estaVacia() const {     return (inicio == NULL); }
\end_layout

\begin_layout Plain Layout

/* Función para eliminar un elemento de una posición determinada.
  */ template <typename Elem> void Lista<Elem>::eliminarLista(int posicion)
 {     // Si la posición es menor a 1 o excede la longitud de la lista,
 entonces     // no hago nada.
     if ((posicion < 1) or (posicion > longLista()) or estaVacia()) {  
       return;     }
\end_layout

\begin_layout Plain Layout

    int actual = 1;     Nodo * aux = inicio;     Nodo * victima;     Nodo
 * anterior = NULL;
\end_layout

\begin_layout Plain Layout

    while (actual < posicion) {         anterior = aux;         aux = aux->sigui
ente;         actual++;     }
\end_layout

\begin_layout Plain Layout

    victima = aux;
\end_layout

\begin_layout Plain Layout

    if (anterior != NULL) {         anterior->siguiente = aux->siguiente;
     } else {         // Se está borrando el primer nodo, por lo tanto hay
 que         // actualizar el puntero de inicio de la lista.
         inicio = aux->siguiente;     }
\end_layout

\begin_layout Plain Layout

    delete victima; }
\end_layout

\begin_layout Plain Layout

/* Función para obtener un valor de la lista.
  */ template <typename Elem> void Lista<Elem>::recuperarLista(int posicion,
 Elem & valor) const {     if ((posicion < 1) or (posicion > longLista())
 or estaVacia()) {         return;     }
\end_layout

\begin_layout Plain Layout

    int actual = 1;     Nodo * aux = inicio;
\end_layout

\begin_layout Plain Layout

    while (actual < posicion) {         actual++;         aux = aux->siguiente;
     }
\end_layout

\begin_layout Plain Layout

    valor = aux->elemento; }
\end_layout

\begin_layout Plain Layout

/* Función para obtener el primer valor de la lista.
  */ template <typename Elem> void Lista<Elem>::leerPrimero(Elem & primero)
 {     if (!estaVacia()) {         primero = inicio->elemento;         punteroPo
sicion = 2;         puntero = inicio->siguiente;     } }
\end_layout

\begin_layout Plain Layout

/* Función para obtener el próximo valor de la lista.
  */ template <typename Elem> void Lista<Elem>::leerSiguiente(Elem & siguiente)
 {     if (!estaVacia()) {         if (punteroPosicion <= longLista()) {
             siguiente = puntero->elemento;             puntero = puntero->sigui
ente;             punteroPosicion++;         }     } }
\end_layout

\begin_layout Plain Layout

// Tipos para los cuales la clase está implementada template class Lista<unsigne
d int>; template class Lista<int>; template class Lista<float>; template
 class Lista<char>; template class Lista<string>;
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection*
Implementación del TDA 
\emph on
Arbin
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily}"
inline false
status open

\begin_layout Plain Layout

CLASS Arbin [Elemento]
\end_layout

\begin_layout Plain Layout

  IMPORTS Nat, Lista
\end_layout

\begin_layout Plain Layout

  BASIC CONSTRUCTORS inicArbin, agregarElemento
\end_layout

\begin_layout Plain Layout

  EFFECTIVE
\end_layout

\begin_layout Plain Layout

    TYPE Arbin
\end_layout

\begin_layout Plain Layout

    OPERATIONS
\end_layout

\begin_layout Plain Layout

      inicArbin: -> Arbin;
\end_layout

\begin_layout Plain Layout

      vacioArbin: Arbin -> Boolean;
\end_layout

\begin_layout Plain Layout

      recuperarRaiz: Arbin(t) -> Elemento
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      agregarElemento: Arbin * Elemento -> Arbin;
\end_layout

\begin_layout Plain Layout

      listarInorden: Arbin(t) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      estaIncluido: Arbin(t) * Elemento -> Boolean
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

      cantidadNodos: Arbin -> Nat;
\end_layout

\begin_layout Plain Layout

      profundidad: Arbin -> Nat;
\end_layout

\begin_layout Plain Layout

      construirFrontera: Arbin(t) -> Lista
\end_layout

\begin_layout Plain Layout

        pre: not vacioArbin(t);
\end_layout

\begin_layout Plain Layout

END-CLASS
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
